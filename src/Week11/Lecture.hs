module Week11.Lecture where

import Control.Applicative (liftA2)

-- Not fully confident in how the parsers are handled. Perhaps we
-- will see in SExpr.

{-

Maybe   | Returns second argument only if both are Just.
[]      | Duplicates each value in second argument for each value in first argument.
ZipList | Nothing special, just return the second list.
IO      | Returns the result of the second IO computation, but keeps effects of both.
Parser  | Runs and ignores output of the first parser, returns output of second parser.

 -}
(.*>) :: Applicative f => f a -> f b -> f b
(.*>) = liftA2 $ const id

{-

Maybe   | Map over a list of Maybes. Returns Just only if `f` is always Just.
[]      | Returns a list of lists, each list generated by f.
ZipList | Same as [],
IO      | Returns a list of results from IO, effect kept separately.
Parser  | Returns a parser for a list.

-}
{-# ANN module "HLint: ignore Use traverse" #-}
mapA' :: Applicative f => (a -> f b) -> ([a] -> f [b])
mapA' f = sequenceA . map f

{-

Maybe   | Convert a list of maybes to a maybe list.
[]      | A list of nondeterministic lists to a nondeterministic list of lists.
ZipList | No real change.
IO      | A list of IO things to an IO list of things. Effect unchanged.
Parser  | A list of parsers to a parser for a list.

-}
sequenceA' :: Applicative f => [f a] -> f [a]
sequenceA' = foldr (liftA2 (:)) (pure [])

{-

Maybe   | Meh.
[]      | Replicate internal list n times.
ZipList | Same as [].
IO      | Replicate result, effect unchanged.
Parser  | Similar to above???


-}
replicateA' :: Applicative f => Int -> f a -> f [a]
replicateA' n = fmap (replicate n)
